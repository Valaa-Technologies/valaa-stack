[
  {
    "@id": "https://valospace.org/raem/VPath/VPath",
    "@context": {
      "@base": "https://valospace.org/raem/VPath/VPath#",
      "sbomdoc": "https://valospace.org/sbomdoc#",
      "revdoc": "https://valospace.org/revdoc#",
      "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
      "xsd": "http://www.w3.org/2001/XMLSchema#",
      "owl": "http://www.w3.org/2002/07/owl#",
      "dc": "http://purl.org/dc/elements/1.1/",
      "vdoc": "https://valospace.org/vdoc#",
      "vdoc:content": {
        "@id": "https://valospace.org/vdoc#content",
        "@container": "@list",
        "@type": "@id"
      },
      "vdoc:words": {
        "@id": "https://valospace.org/vdoc#words",
        "@container": "@list",
        "@type": "@id"
      },
      "vdoc:entries": {
        "@id": "https://valospace.org/vdoc#entries",
        "@container": "@list",
        "@type": "@id"
      },
      "vdoc:headers": {
        "@id": "https://valospace.org/vdoc#headers",
        "@container": "@list",
        "@type": "@id"
      },
      "vdoc:cell": {
        "@id": "https://valospace.org/vdoc#cell",
        "@container": "@list",
        "@type": "@id"
      }
    },
    "dc:title": "ValOS Path",
    "respecConfig": {
      "specStatus": "unofficial",
      "editors": [
        {
          "name": "Iridian Kiiskinen",
          "url": "https://valaatech.github.io/fabric/authors/iridian",
          "github": "http://github.com/valospace"
        }
      ],
      "authors": [],
      "shortName": "VPath"
    },
    "abstract": {
      "@id": "abstract",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "ValOS Paths ('VPaths') are recursively structured general purpose\nstrings. They have a simple grammar making them readily URI embeddable."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "A step below JSON in generality they are the fundamental\nprimitive used by valos to implement resource identifiers, valospace\nqueries, deterministic JSON serialization, an intermediate language\nfor computation, a configuration language, JSON-LD interactions and\nmore."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPaths have a formalized mechanism for making parameterized use of\ncontext-specific definitions. This enables integrations to semantic\nweb. This context-specific yet formally semantic system forms the\ncornerstone of valos security architecture."
          ]
        }
      ]
    },
    "sotd": {
      "@id": "sotd",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "This document is part of the library workspace ",
            {
              "@type": "revdoc:Package",
              "vdoc:content": [
                {
                  "vdoc:em": true,
                  "vdoc:content": [
                    "@valos/raem"
                  ]
                }
              ],
              "vdoc:ref": "@valos/raem"
            },
            "\nbut is only partially implemented by it."
          ]
        }
      ]
    },
    "introduction": {
      "@id": "introduction",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA subset of VPaths called 'vrids' contain a fixed starting point and\nidentify valospace resources."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPaths contain 'context terms' which refer to definitions provided by\nthe surrounding context, usually as references to some external\nontology. This allows VPath semantics to be extended in domain\nspecific but reusable manner."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The primary example of a VPath context is the JSON-LD @context of a ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "ValOS event chronicle"
              ],
              "vdoc:ref": "@valos/sourcerer/valos-event-log"
            },
            "\nwhich provides the semantics for all VPaths that appear inside the\nchronicle.\n    "
          ]
        }
      ]
    },
    "section_structure": {
      "@id": "section_structure",
      "dc:title": "VPath structure",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPath grammar only adds \"@\" and \"$\" in addition to\nencodeURIComponent characters. VPath grammar has two primary building\nblocks: vsteps and vparams."
          ]
        },
        {
          "@type": "vdoc:BulletList",
          "vdoc:entries": [
            [
              "A VPath itself is an ordered sequence of \"@\"-separated vsteps, each\n  of which logically depends on the preceding one."
            ],
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "A vstep can have a 'verb type' and a sequence of vparams, all\n  logically independent of each other."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "A vparam always contains a \"$\"-prefix. The vparam then has\n  an optional context-term and finally a \".\"-prefixed vvalue."
              ]
            }
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPaths serve two superficially distinct purposes as paths and as\nidentifiers. If the first vstep of a VPath begins with a context term\n(ie. doesn't have a verb type) then the whole VPath is valospace\nresource identifier (a *VRID*) and the first vstep is a valospace\nglobal resource identifier (a *VGRID*)."
          ]
        },
        {
          "@id": "main_vpath_rules"
        },
        {
          "@id": "section_vrid_structure"
        },
        {
          "@id": "section_representations"
        }
      ]
    },
    "main_vpath_rules": {
      "@id": "main_vpath_rules",
      "dc:title": "Main VPath rules",
      "@type": "revdoc:Example",
      "vdoc:content": [
        {
          "@type": "revdoc:ABNF",
          "vdoc:language": "https://tools.ietf.org/html/rfc5234",
          "vdoc:content": [
            "  vpath = \"@\" *(vstep \"@\") \"@\"\n  vstep  = [ verb-type ] *vparam\n  vparam = \"$\" [ context-term ] \".\" vvalue\n  vvalue = vpath / \"$\" / 1*( unencoded / pct-encoded )"
          ]
        }
      ]
    },
    "section_vrid_structure": {
      "@id": "section_vrid_structure",
      "dc:title": "VPath with a VGRID is a resource identifier: a VRID",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA VPath with a first vstep lacking a verb type and no other vsteps\nidentifies a global resource."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Many valospace resources, so called *structural sub-resources* are\nidentified by a fixed path from the global resource defined by the same\nverbs that define non-VRID VPaths. Thus while paths and identifiers are\nsuperficially different it is useful to represent them both using the\nsame VPath verb structure."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Both verb and VGRID params can also have context term references to\nan external lookup of URI prefixes and semantic definitions."
          ]
        }
      ]
    },
    "section_representations": {
      "@id": "section_representations",
      "dc:title": "VPath representations",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe canonical VPath is a string, but there are other format specific\nrepresentations.\n      "
          ]
        },
        {
          "@id": "section_vpath_urn"
        },
        {
          "@id": "section_segmented_vpaths"
        },
        {
          "@id": "section_shortcut_vpaths"
        },
        {
          "@id": "section_cemented_vpaths"
        }
      ]
    },
    "section_vpath_urn": {
      "@id": "section_vpath_urn",
      "dc:title": "VPath URN-scheme (tentative)",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA VRID VPath string can be expressed as an URN by removing the \"@\"\nprefix and the \"@@\" suffix and then prefixing the string with\n`urn:valos:`.\n"
          ]
        },
        {
          "@type": "revdoc:Example",
          "vdoc:content": [
            "\nEditorial Note: the urn:valos is fully speculative as of 2019-11. On\none hand there is salient overlap between valos VRID and URN\nprinciples: URN calls for structured and managed process of name\nassignment and resolution and VRID system is precisely that. On the\nother hand VRID defers a lot of detail to specific VGRID format-term\nspecifications which might prove problematic for actual standardization\nprocess. It is possible that instead of a generic urn:valos namespace\nthere would be specific urn namespaces for specific VRID formats (e.g.\nurn:valos-u4, urn:valos-cc) or that urn:valos would stand for one\nspecific format (which would most likely be the ~cc)."
          ]
        }
      ]
    },
    "section_segmented_vpaths": {
      "@id": "section_segmented_vpaths",
      "dc:title": "Segmented VPath representation",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nSegmented VPath is a recursive partitioning of a VPath as a JSON object\nwhere each structural segment is expressed as an array. The first entry\nof each such segment is a string which denotes the segment type and the\nremaining entries contain the segment payload:\n"
          ]
        },
        {
          "@id": "segment_types"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nJSON numbers and strings can only appear as param values of \"$\" or\n\"$.\"-segments. JSON objects cannot appear.\nA VPath which is used as a contextless param of a verb must appear\ndirectly without intermediate \"$.\"-segments (unlike in the string VPath\nconstruct).\nConversely a verb used as a contextless param must still be wrapped\ninside a \"@\"-segment."
          ]
        }
      ]
    },
    "segment_types": {
      "@id": "segment_types",
      "@type": "vdoc:BulletList",
      "vdoc:entries": [
        [
          "\"@\" identifies a VPath segment with remaining entries as step\n  segments"
        ],
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\"$\" identifies a vparam segment with its second entry being a valid\n  context term string and an optional third entry containing the vvalue"
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\"$.\" identifies a vparam segment without a context-term and with an\n  optional second entry containing the vvalue"
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "otherwise the segment type denotes the verb type of a verb segment\n  and remaining entries containing the parameter segments"
          ]
        }
      ]
    },
    "section_shortcut_vpaths": {
      "@id": "section_shortcut_vpaths",
      "dc:title": "Shortcut VPath representation",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nShortcut VPath format is a compact object representation of a VPath as\n'human readable' JSON which can then be distributed to the canonical\nrepresentation. In fact any JSON construct is a valid shortcut VPath,\nand as long as all initial array entries equal to \"@\", \"$\" and \"$.\" are\nescaped as [\"$.\", \"@\"], [\"$.\", \"$\"] and [\"$.\", \"$.\"] the shortcut\nsegment will resolve back into the original JSON construct.\n"
          ]
        }
      ]
    },
    "section_cemented_vpaths": {
      "@id": "section_cemented_vpaths",
      "dc:title": "Cemented VPaths",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVPaths contain context references but do not _contain_ knowledge about\nthe context. This is to ensure that a VPath can be moved from a context\nto a compabible one without modification."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Cementing a VPath with a context inside an environment produces a\nconstruct where the VPath itself and specifically its context terms are\nconverted to their environment-specific representations. This\nrepresentation can be anything from interpretable JSON to fully\ncompiled executable code."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Cementing also performs the security critical function of validating\nthe context terms and their parameters against their context inside\nthat particular environment (e.g. a typical validation failure being\nthe lack of implementation for a specific context term by the\nenvironment)."
          ]
        }
      ]
    },
    "section_semantics": {
      "@id": "section_semantics",
      "dc:title": "VPath semantics",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The full semantics of a particular VPath string in some environment\ncomes from several different sources:"
          ]
        },
        {
          "@id": "semantic_sources"
        },
        {
          "@id": "section_equivalence"
        },
        {
          "@id": "section_context_term"
        },
        {
          "@id": "section_vparam_value"
        },
        {
          "@id": "section_semantic_considerations"
        },
        {
          "@id": "section_verb"
        }
      ]
    },
    "semantic_sources": {
      "@id": "semantic_sources",
      "@type": "vdoc:NumberedList",
      "vdoc:entries": [
        [
          "VPath specification (ie. this document) fully specifies the VPath\n  structure and grammar and defines several verb types"
        ],
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPath extension specifications can define additional conforming verb type semantics"
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPath environment can define context terms directly"
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPath environment can delegate context term definitions to external\n  ontologies"
          ]
        }
      ]
    },
    "section_equivalence": {
      "@id": "section_equivalence",
      "dc:title": "VPath equivalence follows URN equivalence",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nTwo VPaths identify the same path (and in case they're VRIDs, refer to\nthe same resource) iff their URN representations are ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "urn-equivalent"
              ],
              "vdoc:ref": "https://tools.ietf.org/html/rfc8141#section-3"
            },
            " and 1. they either share the same environment or 2. their\ncorresponding context terms expand to URIs which are pair-wise\nURI-equivalent."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "For the general case the actual semantics of a VPath and specifically\nof its context-term's depends on the context it is used. Vrids have a\nfixed context which is established by the VGRID. ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "This has implications on VRID equivalence"
              ],
              "vdoc:ref": "@valos/raem/VPath#section_vrid_equivalence"
            },
            "."
          ]
        }
      ]
    },
    "section_context_term": {
      "@id": "section_context_term",
      "dc:title": " 'context-term' is a lookup to definitions provided by the context",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA VPath can be contextual via the vparam context-term's. These are\ncase-sensitive strings with very restricted grammar. The context where\nthe VPath is used defines the exact meaning of these terms.\nThe meaning for two identical context-terms is recommended to be\nuniform across domains where possible.\nA VPath is invalid in contexts which don't have definitions for the\ncontext-terms of all of its steps. This gives different contexts\na fine-grained mechanism for defining the vocabularies that are\navailable."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Idiomatic example of such context is the event log and its JSON-LD\ncontext structure which is to define both URI namespace prefixes as\nwell as available semantics."
          ]
        }
      ]
    },
    "section_vparam_value": {
      "@id": "section_vparam_value",
      "dc:title": "'vvalue' carries content",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\n*vparams* is a sequence of vparam's, optionally prefixed with\n\"$\" and a context-term. The idiomatic vvalue is a string.\nIf present a context-term may denote a URI prefix in which case the\nvvalue forms the suffix of the full expanded URI reference.\nHowever contexts are free to provide specific semantics for specific\ncontext-terms, such as interpreting them as the value type of the\nvvalue etc."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\"$\" for a vvalue denotes empty string."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "*vvalue* both allows for fully\nunencoded nesting of VPath's as well as allows encoding of all unicode\ncharacters in percent encoded form (as per encodeURIComponent)"
          ]
        }
      ]
    },
    "section_verb": {
      "@id": "section_verb",
      "dc:title": "*verb* - a vstep from a source resource to target resource(s)",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA verb is a one-to-maybe-many relationship between resources. A verb\ncan be as simple as a trivial predicate of a triple or it can represent\nsomething as complex as a fully parameterized computational function\ncall."
          ]
        },
        {
          "@id": "main_verb_rules"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA verb is made up of verb type and a sequence of vparams. The grammar\nof verb-type is restricted but less than for context-term.  The verb\ntype semantics is always fixed. Because of this the first vparam may be\nsemantically special and act as a contextual name of the verb.\n"
          ]
        },
        {
          "@id": "section_verb_type"
        }
      ]
    },
    "main_verb_rules": {
      "@id": "main_verb_rules",
      "dc:title": "Informative verb rules",
      "@type": "revdoc:Example",
      "vdoc:content": [
        {
          "@type": "revdoc:ABNF",
          "vdoc:language": "https://tools.ietf.org/html/rfc5234",
          "vdoc:content": [
            "  vverb        = verb-type *vparam\n  vparam       = \"$\" [ context-term ] \".\" vvalue\n  verb-type    = 1*unencoded\n  context-term = ALPHA *unreserved-nt\n  vvalue       = vpath / \"$\" / 1*( unencoded / pct-encoded )\n"
          ]
        }
      ]
    },
    "section_verb_type": {
      "@id": "section_verb_type",
      "dc:title": "*verb-type*",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\n*verb-type* specifies the relationship category between the segment\nhost resource and sub-resource, a set of inferred triples as well as\nother possible constraints."
          ]
        },
        {
          "@id": "section_verb_property"
        },
        {
          "@id": "section_verb_sequence"
        },
        {
          "@id": "section_verb_container"
        },
        {
          "@id": "section_verb_content"
        },
        {
          "@id": "section_verb_object"
        },
        {
          "@id": "section_verb_ghost"
        },
        {
          "@id": "section_verb_computation"
        }
      ]
    },
    "section_verb_property": {
      "@id": "section_verb_property",
      "dc:title": "verb type \"`.`\": property or ScopeProperty selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb for selecting the resource (typically a ScopeProperty) with the\ngiven name and which has the head as its scope."
          ]
        },
        {
          "@id": "example_verb_property"
        }
      ]
    },
    "example_verb_property": {
      "@id": "example_verb_property",
      "dc:title": "Property selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:.$.myProp> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?o    valos:scope ?s\n      ; valos:name \"myProp\"\n"
          ]
        },
        "Mnemonic: '.' is traditional property accessor (ie. ScopeProperty)."
      ]
    },
    "section_verb_sequence": {
      "@id": "section_verb_sequence",
      "dc:title": "verb type \"`*`\": sequence or Relation selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb for selecting all resources (typically Relations) with the given\nname and which have the head as their source."
          ]
        },
        {
          "@id": "example_verb_sequence"
        }
      ]
    },
    "example_verb_sequence": {
      "@id": "example_verb_sequence",
      "dc:title": "Sequence selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:-out--$.PERMISSIONS> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?o    valos:source ?s\n      ; valos:name \"PERMISSIONS\"\n"
          ]
        },
        "\nMnemonic: '*' for many things as per regex/glob syntax (Relations are\nthe only things that can have multiple instances with the same name)."
      ]
    },
    "section_verb_container": {
      "@id": "section_verb_container",
      "dc:title": "verb type \"`+`\": container or Entity selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb for selecting the resource (typically an Entity) with the given\nname and which has the head as their container."
          ]
        },
        {
          "@id": "example_verb_container"
        }
      ]
    },
    "example_verb_container": {
      "@id": "example_verb_container",
      "dc:title": "Container selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:+$.Scripts> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?o    valos:parent ?s\n      ; valos:name \"Scripts\"\n"
          ]
        },
        "\nMnemonic: \"+\" is a list-view symbol of an expandable container."
      ]
    },
    "section_verb_content": {
      "@id": "section_verb_content",
      "dc:title": "verb type \"`~`\": content or Media selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb for selecting the Media with the given name which has the\nhead as their folder."
          ]
        },
        {
          "@id": "example_verb_content"
        }
      ]
    },
    "example_verb_content": {
      "@id": "example_verb_content",
      "dc:title": "Content selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:~$.foo.vs> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?o    valos:folder ?s\n      ; valos:name \"foo.vs\"\n"
          ]
        },
        "\nMnemonic: \"~\" has no mnemonic yet."
      ]
    },
    "section_verb_object": {
      "@id": "section_verb_object",
      "dc:title": "verb type \"`.O`\": object or target selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb that is a synonym for predicate 'rdf:object'."
          ]
        },
        {
          "@id": "example_verb_object"
        }
      ]
    },
    "example_verb_object": {
      "@id": "example_verb_object",
      "dc:title": "Property selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:.O> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?s    rdf:object ?o\n"
          ]
        },
        "\nMnemonic: follow line '-' to target."
      ]
    },
    "section_verb_ghost": {
      "@id": "section_verb_ghost",
      "dc:title": "verb type \"`_`\": subspace selector",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVerb for selecting named subspaces and ghosts."
          ]
        },
        {
          "@id": "example_verb_language_subspace"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "If the verb name context term is an identifier term then the subspace\ndenotes the ghost subspace of the identified resource inside the\ncurrent resource."
          ]
        },
        {
          "@id": "example_verb_ghost_subspace"
        }
      ]
    },
    "example_verb_language_subspace": {
      "@id": "example_verb_language_subspace",
      "dc:title": "Language subspace selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:.$.myProp@_$lang.fi> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?_sp  valos:scope ?s\n      ; valos:name \"myProp\"\n  . ?o  valos:subspacePrototype* ?_sp\n      ; valos:language \"fi\"\n"
          ]
        },
        "\nMnemonic: '_' is underscore is subscript is subspace."
      ]
    },
    "example_verb_ghost_subspace": {
      "@id": "example_verb_ghost_subspace",
      "dc:title": "Ghost subspace selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:_$~u4.ba54> ?o` matches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?o    valos:ghostHost ?s\n      ; valos:ghostPrototype <urn:valos:$~u4.ba54>\n"
          ]
        },
        "\nMnemonic: The '_$~' is a 'subspace of ghoStS'."
      ]
    },
    "section_verb_computation": {
      "@id": "section_verb_computation",
      "dc:title": "verb type \"`!`\": computation evaluators",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVPaths are data. In general whenever a representation of a VPath\nappears in some ",
            {
              "vdoc:em": true,
              "vdoc:content": [
                "evaluation context"
              ]
            },
            " the representation\nevaluates into itself. The only exception are the verbs with `!` as\nthe leading character of their type: these represent the class of\ncomputation evaluators."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "VPath spec tries to specify as little as possible. As such it doesn't\nspecify an execution model itself but delegates this to context term\nontologies. VPath only provides a way to specify evaluation dependency\nchains and the mapping between VPath data structures and evaluator\ninputs and outputs."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Following principles apply:"
          ]
        },
        {
          "@type": "vdoc:NumberedList",
          "vdoc:entries": [
            [
              "The different evaluator verb types only specify the means to access\n  and process the VPath data structure itself. These\n  `evaluator types` are defined by the VPath specification(s)."
            ],
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "All computation (f.ex. flow control and method call) semantics are\n  specified by the first vpath param of the evaluator verb, ie. the\n  `computation id`. This specification shall be provided by the\n  ontology that defines the context-term of the computation id param."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "If the computation id doesn't have a context-term of if the\n  specification denotes the computation id to be a `trivial name`\n  then the computation is a `context scope lookup path`."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "When a computation evaluator is evaluated all of its vparams are\n  evaluated first in an order defined by the evaluation context and\n  their results stores as evaluation arguments."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "The evaluation context is then searched for an implementation for the\n  evaluator type / computation id combination. If none is found the\n  context does not implement the computation and the whole evaluation\n  chain is rejected."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "The evaluation implementation is resolved with the evaluation\n  arguments and its result is the result of the computation\n  evaluator."
              ]
            }
          ]
        },
        {
          "@type": "revdoc:Example",
          "vdoc:content": [
            "\nEditorial Note: this section should be greatly improved.\nThe purpose of computation verbs lies more on representing various\nconversions (as part of dynamic operations such as web API route\nmapping) and less on clever SPARQL trickery. The illustration here uses\n(questionable) SPARQL primarily for consistency."
          ]
        },
        {
          "@id": "example_verb_computation"
        }
      ]
    },
    "example_verb_computation": {
      "@id": "example_verb_computation",
      "dc:title": "Computation selector example",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "Triple pattern `?s <urn:valos:!$valk.add$number.10$.@!$.myVal@@> ?o`\nmatches like:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  ?_:0  valos:scope ?s\n      ; valos:name \"myVal\"\n      ; valos:value ?myVal\n  . FILTER (?o === 10 + ?myVal)\n"
          ]
        }
      ]
    },
    "section_semantic_considerations": {
      "@id": "section_semantic_considerations",
      "dc:title": "Semantic design choices and guidelines",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "As VPath structure is expressive there are often multiple ways to\nexpress a particular design need. Following juxtapositions and\nguidelines apply:"
          ]
        },
        {
          "@type": "vdoc:BulletList",
          "vdoc:entries": [
            [
              "\"vsteps vs. vparams\" or \"How should I express a sequence?\":\n  If the entries of a sequence depend on each other (e.g. in a query or\n  in an execution list) they are vsteps, if not (e.g. data entries)\n  they are vparams of a vstep."
            ],
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "\"verb type vs. context term\" or \"How should I express a concept?\":\n  If the concept is interaction logic, domain specific, visible to the\n  end-users or it doesn't require infrastructure code changes it is\n  probably a context term with URI expansion to some ontology.\n  If the concept concerns VPath structure or its interpretation and is\n  generic enough to warrant a specification and corresponding\n  infrastructure implementation work it is possibly a verb type with\n  new extension spec or new release of an existing spec."
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "\"!-computational vs. declarational\" or \"Who writes the code?\":\n  Computational vsteps (those with verb type beginning with \"!\") allow\n  for turing-complete computation to be embedded inside VPaths. An\n  environment that chooses to support these verbs and context terms\n  has the upside of rapid and arbitrarily expressive configurability\n  without further code changes. The downside is that security and\n  complexity analysis becomes intractable even more rapidly.\n  Declarational vsteps (all other verb types) require explicit\n  interpretation but should be preferred when meaningful semantics can\n  be specified."
              ]
            }
          ]
        }
      ]
    },
    "section_vrid": {
      "@id": "section_vrid",
      "dc:title": "VRID is a stable identifier of a global resource or a structural sub-resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA VRID is a VPath which has VGRID as its first production\n(via vgrid-tail)."
          ]
        },
        {
          "@id": "main_vrid_rules"
        },
        {
          "@id": "section_vgrid"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe VRID can be directly used as the NSS part of an 'urn:valos:'\nprefixed URI."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Each valospace resource is identified by a VRID."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "If a resource VRID has only VGRID part but no verbs the resource is\ncalled a global resource."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "If a resource VRID has verbs then the verbs describe a structural path\nfrom the global resource of its initial VGRID part to the resource\nitself. The resource is called a *structural sub-resource* of that\nglobal resource."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Each resource is affiliated with an event log of its global resource."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "All direct VRID context-terms are references to this event log ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "JSON-LD context"
              ],
              "vdoc:ref": "https://w3c.github.io/json-ld-syntax/#the-context"
            },
            "."
          ]
        },
        {
          "@id": "section_vrid_event_log"
        },
        {
          "@id": "section_vrid_equivalence"
        },
        {
          "@id": "section_structural_sub_resources"
        },
        {
          "@id": "section_vgrid_types"
        },
        {
          "@id": "section_vrid_verb_types"
        }
      ]
    },
    "main_vrid_rules": {
      "@id": "main_vrid_rules",
      "dc:title": "Informative VRID rules",
      "@type": "revdoc:Example",
      "vdoc:content": [
        {
          "@type": "revdoc:ABNF",
          "vdoc:language": "https://tools.ietf.org/html/rfc5234",
          "vdoc:content": [
            "  vrid        = \"@\" \"$\" vgrid \"@\" *(vstep \"@\") \"@\"\n  vgrid       = format-term \".\" vgrid-value *vparam\n"
          ]
        }
      ]
    },
    "section_vgrid": {
      "@id": "section_vgrid",
      "dc:title": "VGRID identifies global resources - primary keys, free ownership, concrete state",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe VGRID uniquely identifies a *global resource*. If a VRID contains\na VGRID and no verbs this global resource is also the\n*referenced resource* of the VRID itself."
          ]
        },
        {
          "@id": "main_vgrid_rules"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe format-term defines the global resource identifier schema as well\nas often some (or all) characteristics of the resource."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "format-term and vgrid-value are subsets of verb-type and vvalue; VGRID\nrestricts the grammar of these to unreserved-nt as specified in\nthe ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "URI specification"
              ],
              "vdoc:ref": "https://tools.ietf.org/html/rfc3986"
            },
            ")."
          ]
        },
        {
          "@type": "revdoc:Example",
          "vdoc:content": [
            "\nNote: when using base64 encoded values as VGRID vvalue, use the\nurl-and-filename-ready",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "base64url characters"
              ],
              "vdoc:ref": "https://tools.ietf.org/html/rfc4648#section-5"
            },
            "."
          ]
        }
      ]
    },
    "main_vgrid_rules": {
      "@id": "main_vgrid_rules",
      "dc:title": "Informative VGRID rules",
      "@type": "revdoc:Example",
      "vdoc:content": [
        {
          "@type": "revdoc:ABNF",
          "vdoc:language": "https://tools.ietf.org/html/rfc5234",
          "vdoc:content": [
            "  vgrid         = format-term \".\" vgrid-value *vparam\n  format-term   = \"~\" 1*unreserved-nt\n  vgrid-value   = 1*unreserved-nt\n\n  unreserved-nt = ALPHA / DIGIT / \"-\" / \"_\" / \".\"\n  ALPHA         = %x41-5A / %x61-7A                         ; A-Z / a-z\n  DIGIT         = %x30-39                                   ; 0-9\n"
          ]
        }
      ]
    },
    "section_vrid_event_log": {
      "@id": "section_vrid_event_log",
      "dc:title": "VRID is affiliated with an event log",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe resource identified by a VRID is always affiliated with an event\nlog of its global resource. Because the VRID doesn't contain the\nlocator information of this event log it must be discoverable from the\ncontext where the VRID is used."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "All context-terms of the VGRID and VRID vparams are references to the\nevent log ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "JSON-LD context"
              ],
              "vdoc:ref": "https://w3c.github.io/json-ld-syntax/#the-context"
            },
            " (Note: this applies only to immediate but not to nested vparams)."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Global resources can be transferred between event logs. To maintain\nimmutability across these transfers VGRID's must not contain chronicle\nor other non-identifying locator information. Similar to URN's VRID's\nalways relies external structures and systems for carrying locator\ninformation.\n"
          ]
        },
        {
          "@type": "revdoc:Example",
          "vdoc:content": [
            "Note: uuid v4 (format term `~u4`) is recommended for\nnow, but eventually VGRID generation will be tied to the\ndeterministic event id chain (format term `~cc`).\nThis in turn should be seeded by some ValOS authority."
          ]
        }
      ]
    },
    "section_vrid_equivalence": {
      "@id": "section_vrid_equivalence",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nTwo VRIDs refer to the same resource iff their URN representations are ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "urn-equivalent"
              ],
              "vdoc:ref": "https://tools.ietf.org/html/rfc8141#section-3"
            },
            "(i.e. if the two VRIDs are equivalent after section 3.1. case\nnormalization for step 3. percent-encoding case normalization)."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Maintaining the consistency between this lexical equivalence and the\nsemantic equivalence of a resource which has been transferred between\nevent logs without having to dereference VRIDs is useful but has\nimplications.\n",
            {
              "vdoc:blockquote": true,
              "vdoc:content": [
                "Rule: When resources are transferred between event logs\n  the semantics of their context terms and body-parts must remain\n  equivalent."
              ]
            }
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "A *simple equivalence* is that two simple prefix term definitions\nresolve to the same URI. An *extended equivalence* is when two extended\nterm definitions in the source and target event logs are equivalent\nafter normalization. These two equivalences are [will be] defined by\nthis document."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "More complex equivalences are outside the scope of this document but\ncan be defined by specifications specifying segment types. These\nequivalences might take details of the particular verb-type into\naccount and/or specify context definition additions which do not change\nthe equivalence semantics."
          ]
        }
      ]
    },
    "section_structural_sub_resources": {
      "@id": "section_structural_sub_resources",
      "dc:title": "VRID verbs identify structural sub-resources - fixed ownership, inferred state, 'secondary keys'",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "In VRID context the vsteps-tail that follows the VGRID specifies\na structural path from the global resource to a\n*structural sub-resource* of the global resource. The triple\nconstraints of each verb in that path are _inferred as triples_ for the\nparticular resource that that verb affects."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            {
              "vdoc:blockquote": true,
              "vdoc:content": [
                "Principle: a structural sub-resource using a particular\nvsteps-tail in its identifying VRID will always infer the triples that\nare required to satisfy the same vsteps-tail in a query context which\nstarts from the same global resource."
              ]
            }
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "This fixed triple inference is the meat and bones of the structural\nsub-resources: they allow for protected, constrained semantics to be\nexpressed in the valospace resources. This allows both simplified\nsemantics (eg. properties _cannot_ be renamed so the complex\nfunctionality doesn't need to be supported on fabric level), more\nprincipled mechanism for chronicle crypto behaviours (permission\nrelations are structural sub-resources which simplifies security\nanalysis but retains valospace convenience) and also a mechanism for\nexpressing non-trivial resources such as hypertwin resources."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The sub-resources can be nested and form a tree with the global\nresource as the root. Typical verb sub-segments specify the edges in\nthis tree (some verbs only specify the current node resource further\nwithout specifying a new edge). The global resource is the host\nresource for the first verb; the sub-resource of that segment is the\nhost resource of the second verb and so on."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "As the VRID identities of the sub-resources are structurally fixed to\nthis tree the coupling between host and sub-resource must be static.\nThe typical implementation for this is an ownership coupling."
          ]
        }
      ]
    },
    "section_vgrid_types": {
      "@id": "section_vgrid_types",
      "dc:title": "List of VGRID formats:",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVGRID context-term specifies the particular identifier format and\npossible semantics of the identified global resource. ValOS kernel\nreserves all context-terms matching '\"i\" 2( ALPHA / DIGIT )' for\nitself with currently defined formats exhaustively listed here.\n      "
          ]
        },
        {
          "@id": "section_vgrid_uuid_v4"
        },
        {
          "@id": "section_vgrid_content_hash"
        },
        {
          "@id": "section_vgrid_platonic_resource"
        },
        {
          "@id": "section_vgrid_command_resource_hash"
        },
        {
          "@id": "section_vgrid_command_chronicle_hash"
        },
        {
          "@id": "section_vgrid_crypto_chained"
        },
        {
          "@id": "section_vgrid_authority_root"
        },
        {
          "@id": "section_vgrid_ghost"
        },
        {
          "@id": "section_vgrid_raw"
        }
      ]
    },
    "section_vgrid_uuid_v4": {
      "@id": "section_vgrid_uuid_v4",
      "dc:title": "VGRID format \"`~u4`\": UUID v4 of a native, insecure resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn identifier for native valospace resource with an event log.\nThis is insecure as there are no guarantees against resource id\ncollisions by malicious event logs. These identifiers can thus only be\nused in trusted, protected environments."
          ]
        }
      ]
    },
    "section_vgrid_content_hash": {
      "@id": "section_vgrid_content_hash",
      "dc:title": "VGRID format \"`~bvo`\": The content hash of Binary ValOS object",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn identifier of an immutable octet-stream, with the content hash in\nthe vvalue."
          ]
        }
      ]
    },
    "section_vgrid_platonic_resource": {
      "@id": "section_vgrid_platonic_resource",
      "dc:title": "VGRID format \"`~plt`\": The id of an immutable Platonic resource With inferences",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn identifier of an immutable, procedurally generated resource with its\ncontent inferred from the VPath embedded in the vvalue.\nWhile of limited use in itself this is useful when used as the\nprototype of structural ghost sub-resources which are quite mutable."
          ]
        }
      ]
    },
    "section_vgrid_command_resource_hash": {
      "@id": "section_vgrid_command_resource_hash",
      "dc:title": "VGRID format \"`~cih`\": The id of a command-id hash-based insecure resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn identifier which has been hashed from a command id, chronicle URI\nand a running counter."
          ]
        }
      ]
    },
    "section_vgrid_command_chronicle_hash": {
      "@id": "section_vgrid_command_chronicle_hash",
      "dc:title": "VGRID format \"`~chr`\": The id of a command hash-based chronicle",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nA chronicle identifier which has been hashed from a command id and an\nauthority URI."
          ]
        }
      ]
    },
    "section_vgrid_crypto_chained": {
      "@id": "section_vgrid_crypto_chained",
      "dc:title": "VGRID format \"`~ch3`\": The id of Crypto-Hash-CHained secure CHronicle resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn identifier of a native, secure valospace resource with an event log.\nThis id is deterministically derived from the most recent hash-chain\nevent log entry of the particular event which created it, the\ncryptographic secret of the creating identity and a salt, thus ensuring\ncollision resistance and a mechanism for creator to prove their claim\nto the resource."
          ]
        }
      ]
    },
    "section_vgrid_authority_root": {
      "@id": "section_vgrid_authority_root",
      "dc:title": "VGRID format \"`~aur`\": The id of an authority root resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThe fixed identifier of an immovable root resource of an authority\nchronicle. The authority VGRID param equals to the authority URI."
          ]
        }
      ]
    },
    "section_vgrid_ghost": {
      "@id": "section_vgrid_ghost",
      "dc:title": "VGRID format \"`~gh`\": The derived Hash id of a native, insecure Ghost resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThis is a legacy format for native ghost resources, with id created\nfrom the hash of the 'ghost path' of the resource."
          ]
        }
      ]
    },
    "section_vgrid_raw": {
      "@id": "section_vgrid_raw",
      "dc:title": "VGRID format \"`~raw`\": The insecure raw text id of a resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nAn id with an unknown schema."
          ]
        }
      ]
    },
    "section_vrid_verb_types": {
      "@id": "section_vrid_verb_types",
      "dc:title": "List of VRID-specific verb type semantics:",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVRID *verb-type* specifies the relationship category between the\nsegment host resource and sub-resource, a set of inferred triples as\nwell as other possible constraints."
          ]
        },
        {
          "@id": "example_shared_vrid_verb_data"
        },
        {
          "@id": "section_structural_ghost"
        },
        {
          "@id": "section_structural_subspace"
        },
        {
          "@id": "section_structural_scope_property"
        },
        {
          "@id": "section_structural_relation"
        },
        {
          "@id": "section_structural_entity"
        },
        {
          "@id": "section_structural_media"
        }
      ]
    },
    "example_shared_vrid_verb_data": {
      "@id": "example_shared_vrid_verb_data",
      "dc:title": "Shared example data",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "The examples below all share the following triples:",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b> a valos:Entity\n      ; valos:prototype <urn:valos:$~u4.f00b-b507-0763>\n"
          ]
        }
      ]
    },
    "section_structural_ghost": {
      "@id": "section_structural_ghost",
      "dc:title": "verb type \"`_`\": structural subspace sub-resource",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nGhost sub-resources are products of ghost instantiation. All the ghosts\nof the directly _and indirectly_ owned resources of the instance\nprototype are flattened as _direct_ structural sub-resources of the\ninstance itself. The instance is called *ghost host* of all such ghosts."
          ]
        },
        {
          "@id": "example_structural_ghost"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nIn case of deeper instantiation chains the outermost ghost segment\nprovides inferences recursively to all of its sub-resources; nested\nghost segments wont provide any further inferences."
          ]
        },
        {
          "@id": "example_structural_ghost_recursive"
        }
      ]
    },
    "example_structural_ghost": {
      "@id": "example_structural_ghost",
      "dc:title": "Structural ghost triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@_$~u4.ba54>` reads as \"inside the\ninstance resource `f00b` the ghost of the $~u4 resource `ba54`\"\nand infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@_$~u4.ba54>\n        valos:ghostHost <urn:valos:$~u4.f00b>\n      ; valos:ghostPrototype <urn:valos:$~u4.ba54>\n"
          ]
        }
      ]
    },
    "example_structural_ghost_recursive": {
      "@id": "example_structural_ghost_recursive",
      "dc:title": "Recursive ghost triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@_$~u4.ba54@_$~u4.b7e4>` reads as \"inside\nthe instance resource `f00b` the ghost of\n`<urn:valos:$~u4.ba54@_$~u4.b7e4>`\" and infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@_$~u4.ba54@_$~u4.b7e4>\n        valos:ghostHost <urn:valos:$~u4.f00b>\n      ; valos:ghostPrototype <urn:valos:$~u4.ba54@_$~u4.b7e4>\n"
          ]
        }
      ]
    },
    "section_structural_subspace": {
      "@id": "section_structural_subspace",
      "dc:title": "verb type \"`_`\": structural subspace override",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nSelects a variant resource value for a base resource within a\nstructurally identified subspace. The variant resource provides\ninferred `subspacePrototype` fallbacks to an *inner* subspace and\neventually to the non-variant base resource as well as to the\nhomologous sub-resource of the host resource inheritancePrototype."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "This means that no matter where a subspace variant is defined in\nthe prototype chain or in the nested sub-structure its value will be\nfound."
          ]
        },
        {
          "@id": "example_structural_subspace"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nSubspace selectors can be used to access language variants,\nstatically identified ghost variants within an instance, statically\nidentified Relation's etc."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The verb segment-term can also specify triple inferences for *all*\nsub-resources in the subspace (not just for the immediate\nsub-resource of the selector segment)."
          ]
        },
        {
          "@id": "example_structural_subspace_recursive"
        }
      ]
    },
    "example_structural_subspace": {
      "@id": "example_structural_subspace",
      "dc:title": "Structural subspace triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@.$.myProp@_$lang.fi>` is a lang fi variant of\nf00b myProp and infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@.$.myProp@_$lang.fi> a valos:ScopeProperty\n      ; valos:subspacePrototype <urn:valos:$~u4.f00b@.$.myProp>\n                              , <urn:valos:$~u4.f00b-b507-0763@.$.myProp@_$lang.fi>\n      ; valos:language \"fi\"\n"
          ]
        }
      ]
    },
    "example_structural_subspace_recursive": {
      "@id": "example_structural_subspace_recursive",
      "dc:title": "Structural subspace recursive inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@_$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp>`\ninfers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@_$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp> a valos:ScopeProperty\n      ; valos:ghostHost <urn:valos:$~u4.f00b>\n      ; valos:ghostPrototype <urn:valos:$~u4.b453@_$lang.fi@_$~u4.b74e@.$.myProp>\n      ; valos:subspacePrototype <urn:valos:$~u4.f00b@_$~u4.b453@_$~u4.b74e@_$lang.fi@.$.myProp>\n      ; valos:language \"fi\"\n"
          ]
        }
      ]
    },
    "section_structural_scope_property": {
      "@id": "section_structural_scope_property",
      "dc:title": "verb type \"`.`\": structural ScopeProperty",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nStructural properties infer a type, fixed owner and name."
          ]
        },
        {
          "@id": "example_structural_scope_property"
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The verbs `.O.`, `.O+`, and `.O~` denote the properties\n`valos:value`, `valos:id`, and `valos:content'` respectively.\nThese are the primary ",
            {
              "vdoc:em": true,
              "vdoc:content": [
                "rdf:object sub-properties"
              ]
            },
            " of\nScopeProperty, Entity and Media, respectively (the 'O' in the\nverbs stands for rdf:object). When given as a parameter to a primary\nresource they modify it with a fixed rdf:object triple.\nIn addition `.S-` and `.O-` denote `valos:source` `valos:target`\nwhich are the rdf:subject and rdf:object properties of a Relation."
          ]
        },
        {
          "@id": "example_structural_object"
        }
      ]
    },
    "example_structural_scope_property": {
      "@id": "example_structural_scope_property",
      "dc:title": "Structural scope property triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@.$.myProp>` is a resource with fixed name\n\"myProp\", dominant type ScopeProperty, $~u4 resource f00b as the owning\nscope and a structurally homologous prototype inside\nf00b-b507-0763 and thus infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@.$.myProp> a valos:ScopeProperty\n      ; valos:scope <urn:valos:$~u4.f00b>\n      ; valos:inheritancePrototype <urn:valos:$~u4.f00b-b507-0763@.$.myProp>\n      ; valos:name \"myProp\"\n"
          ]
        }
      ]
    },
    "example_structural_object": {
      "@id": "example_structural_object",
      "dc:title": "Structural rdf:object triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@-out--$.PERMISSIONS:@.O-$~ih.8766>` is a PERMISSIONS\nrelation with fixed ~ih target 8766 and infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@-out--$.PERMISSIONS:@.O-$~ih.8766> a valos:Relation\n      ; valos:connectedSource <urn:valos:$~u4.f00b>\n      ; valos:prototype <urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS:@.O-$~ih.8766>\n      ; valos:name \"PERMISSIONS\"\n      ; valos:target <urn:valos:$~u4.8766>\n"
          ]
        },
        "Mnemonic: these verbs are read right-to-left, eg. `.O-` -> 'Relation\nrdf:object property is valos:target'"
      ]
    },
    "section_structural_relation": {
      "@id": "section_structural_relation",
      "dc:title": "verb type \"`*`\": structural Relation",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nStructural relations infer a type, fixed owner (connector), name and\npossibly source and target."
          ]
        },
        {
          "@id": "example_structural_relation"
        }
      ]
    },
    "example_structural_relation": {
      "@id": "example_structural_relation",
      "dc:title": "Structural relation triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@-out--$.PERMISSIONS@_$.1>` is a resource with\nfixed name \"PERMISSIONS\", dominant type Relation, ~u4 f00b as the\nsource, a structurally homologous prototype inside f00b-b507-0763\nand thus infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@-out--$.PERMISSIONS> a valos:Relation\n      ; valos:connectedSource <urn:valos:$~u4.f00b>\n      ; valos:inheritancePrototype <urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS>\n      ; valos:name \"PERMISSIONS\"\n  <urn:valos:$~u4.f00b@-out--$.PERMISSIONS@_$.1> a valos:Relation\n      ; valos:subspacePrototype <urn:valos:$~u4.f00b@-out--$.PERMISSIONS>\n                              , <urn:valos:$~u4.f00b-b507-0763@-out--$.PERMISSIONS@_$.1>\n"
          ]
        }
      ]
    },
    "section_structural_entity": {
      "@id": "section_structural_entity",
      "dc:title": "verb type \"`+`\": structural Entity",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nStructural entities infer a type, fixed owner (parent) and name."
          ]
        },
        {
          "@id": "example_structural_entity"
        }
      ]
    },
    "example_structural_entity": {
      "@id": "example_structural_entity",
      "dc:title": "Structural Entity triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@+$.Scripts>` has a fixed name \"scripts\",\ndominant type Entity, $~u4 resource f00b as the owning container and\na structurally homologous prototype inside f00b-b507-0763 and thus\ninfers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@+$.Scripts> a valos:Entity\n      ; valos:parent <urn:valos:$~u4.f00b>\n      ; valos:inheritancePrototype <urn:valos:$~u4.f00b-b507-0763@+$.Scripts>\n      ; valos:name \"scripts\"\n"
          ]
        }
      ]
    },
    "section_structural_media": {
      "@id": "section_structural_media",
      "dc:title": "verb type \"`~`\": structural Media",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nStructural medias infer a type, fixed owner (folder) and name."
          ]
        },
        {
          "@id": "example_structural_media"
        }
      ]
    },
    "example_structural_media": {
      "@id": "example_structural_media",
      "dc:title": "Structural Media triple inference",
      "@type": "revdoc:Example",
      "vdoc:content": [
        "`<urn:valos:$~u4.f00b@~$.foo.vs>` has a fixed name \"foo.vs\", dominant\ntype Media, $~u4 resource f00b as the owning folder and a structurally\nhomologous prototype inside f00b-b507-0763 and thus infers triples:\n",
        {
          "@type": "revdoc:Turtle",
          "vdoc:language": "https://www.w3.org/TR/turtle/",
          "vdoc:content": [
            "\n  <urn:valos:$~u4.f00b@~$.foo.vs> a valos:Media\n      ; valos:folder <urn:valos:$~u4.f00b>\n      ; valos:inheritancePrototype <urn:valos:$~u4.f00b-b507-0763@~$.foo.vs>\n      ; valos:name \"foo.vs\"\n"
          ]
        }
      ]
    },
    "section_grammar": {
      "@id": "section_grammar",
      "dc:title": "Collected VPath ABNF grammar",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The VPath grammar is an LL(1) grammar. It is recursive be virtue of\nvvalue productions which can nest VPaths themselves without additional\nencoding."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The list of definitive rules:\n",
            {
              "@type": "revdoc:ABNF",
              "vdoc:language": "https://tools.ietf.org/html/rfc5234",
              "vdoc:content": [
                "  vpath         = \"@\" *(vstep \"@\") \"@\"\n  vstep         = [ verb-type ] *vparam\n  vparam        = \"$\" [ context-term ] \".\" vvalue\n  vvalue        = vpath / \"$\" / 1*( unencoded / pct-encoded )\n\n  verb-type     = 1*unencoded\n  context-term  = 1*unreserved\n  unencoded     = unreserved / \"!\" / \"*\" / \"'\" / \"(\" / \")\"\n  unreserved    = unreserved-nt / \"~\"\n  unreserved-nt = ALPHA / DIGIT / \"-\" / \"_\" / \".\"\n  pct-encoded   = \"%\" HEXDIG HEXDIG\n\n  ALPHA         = %x41-5A / %x61-7A                         ; A-Z / a-z\n  HEXDIG        = DIGIT / \"A\" / \"B\" / \"C\" / \"D\" / \"E\" / \"F\" ; 0-9 / A-F\n  DIGIT         = %x30-39                                   ; 0-9"
              ]
            }
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "In addition there are pseudo-rules which are not used by an LL(1)\nparser but which have well-defined meaning and can thus be referred to\nfrom other documents."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "The list of informative pseudo-rules:\n",
            {
              "@type": "revdoc:ABNF",
              "vdoc:language": "https://tools.ietf.org/html/rfc5234",
              "vdoc:content": [
                "  vverb           = verb-type *vparam\n  vcontext-param  = \"$\" context-term \".\" vvalue\n\n  vrid            = \"@\" \"$\" vgrid \"@\" *(vstep \"@\") \"@\"\n  vgrid           = format-term \".\" vgrid-value *vparam\n  format-term     = \"~\" 1*(ALPHA / DIGIT / \"_\")\n  vgrid-value     = 1*( unencoded / pct-encoded )\n\n  context-term-ns = ALPHA 0*30unreserved-nt ( ALPHA / DIGIT )\n"
              ]
            }
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "There are couple notes not explicitly expressed by the the grammar\nitself. These notes primarily relate to LL(1)-parseability:"
          ]
        },
        {
          "@type": "vdoc:BulletList",
          "vdoc:entries": [
            [
              "Pseudo-rule 'vrid': this class contains all 'vpath' productions with\n  'vgrid' as their first expansion."
            ],
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "Pseudo-rule 'context-term-ns': this class contains all 'context-term'\n  expansions which match this more restrictive specification (max 32\n  chars, special chars only in the middle). All 'context-term's which\n  are plain namespace prefixes should be restricted to this rule as\n  this is the prefix grammar of some relevant prefix context.\n  ",
                {
                  "@type": "revdoc:Example",
                  "vdoc:content": [
                    "Editorial Note: which context was this again? Neither\n    SPARQL, Turtle nor JSON-LD have this limitation."
                  ]
                }
              ]
            },
            {
              "@type": "vdoc:Paragraph",
              "vdoc:content": [
                "The nesting hierarchy can be manually quickly established by first\n  splitting a valid VPath string by the delimiter regex /(@$.)/\n  (retaining these delimiters in the result). Then a tree structure is\n  formed by traversing the array from left to right and dividing it to\n  different nesting depths. The nesting depth is increased for the\n  initial \"@\" and for each \"@\" that is preceded by a \".\" (corresponds\n  to the 'vpath' production prefix of some 'short-param' production)\n  and reducing the nesting depth for each \"@\" that is succeeded by a\n  \"$\", \"@\" or EOF (corresponds to the terminator of the last\n  'vgrid' or 'verb' production of some 'vpath' production). All\n  remaining \"@\" correspond to non-final 'vgrid' or 'verb' production\n  terminators of some 'vpath' rule production and thus don't change the\n  nesting depth."
              ]
            }
          ]
        }
      ]
    },
    "section_encoding_considerations": {
      "@id": "section_encoding_considerations",
      "dc:title": "VPath design considerations and case studies",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThis section contains considerations on the choice of character set and\non where and how VPaths need or don't need to be encoded. There's a\nhistorical emphasis on the decision of which characters to use as\ndelimiters (ie. \"@\", and \"$\")."
          ]
        },
        {
          "@id": "section_robust_composition"
        },
        {
          "@id": "section_unencoded_contexts"
        },
        {
          "@id": "section_encoded_contexts"
        },
        {
          "@id": "section_tilde_problem"
        }
      ]
    },
    "section_robust_composition": {
      "@id": "section_robust_composition",
      "dc:title": "VPath composition and decomposition should be robust",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@id": "section_no_contextual_delimiters"
        },
        {
          "@id": "section_consistent_encoding"
        }
      ]
    },
    "section_no_contextual_delimiters": {
      "@id": "section_no_contextual_delimiters",
      "dc:title": "No contextual delimiters",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nIf a character is a delimiter in some context within a VPath then this\ncharacter must always encoded when not used as a delimiter."
          ]
        }
      ]
    },
    "section_consistent_encoding": {
      "@id": "section_consistent_encoding",
      "dc:title": "All value segments are encoded and decoded using encodeURIComponent",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nCharacters not encoded are ruled out from structural delimiters.\nThis leaves \"?\" | \"#\" and \"/\" | \":\" | \"@\" and \"$\" | \"+\" | \";\" | \",\" | \"=\" | \"&\""
          ]
        }
      ]
    },
    "section_unencoded_contexts": {
      "@id": "section_unencoded_contexts",
      "dc:title": "Contexts where VPath doesn't need encoding",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nIn general VPaths don't require encoding in contexts where the VPath\ndelimiters \"@\" / \"$\" and the encodeURIComponent result character set\nALPHA / DIGIT / \"-\" / \"_\" / \".\" / \"~\" / \"!\" / \"*\" / \"'\" / \"(\" / \")\"\ncan be used.\n",
            {
              "vdoc:blockquote": true,
              "vdoc:content": [
                "Editorial Note: \"(\" and \")\" can in principle be\n  substantially inconvenient in many contexts. But as they're grouped\n  with \"!\" / \"*\" / \"'\" which have their uses in verb-type's all\n  five are for now retained as allowed characters."
              ]
            }
          ]
        },
        {
          "@id": "section_unencoded_in_rfc_3986_segment_nz"
        },
        {
          "@id": "section_unencoded_in_sequences"
        },
        {
          "@id": "section_unencoded_in_rfc_3986_query"
        },
        {
          "@id": "section_unencoded_in_rfc_3986_fragment"
        },
        {
          "@id": "section_unencoded_in_rfc_8141_nss"
        },
        {
          "@id": "section_unencoded_in_rfc_8141_rq_f"
        }
      ]
    },
    "section_unencoded_in_rfc_3986_segment_nz": {
      "@id": "section_unencoded_in_rfc_3986_segment_nz",
      "dc:title": "As RFC 3986 URI segment-nz component",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVPaths can be used as-is in URI path parts (except as segment-nz-nc, see below).\nThis rules out \"?\", \"#\", \"/\" from structural delimiters"
          ]
        }
      ]
    },
    "section_unencoded_in_sequences": {
      "@id": "section_unencoded_in_sequences",
      "dc:title": "As a typical sequence entry",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nRules out \",\" | \";\" from structural delimiters"
          ]
        }
      ]
    },
    "section_unencoded_in_rfc_3986_query": {
      "@id": "section_unencoded_in_rfc_3986_query",
      "dc:title": "As part of RFC 3986 URI query component when consumer is known not to decode",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nVPath can and is intended to be used as-is in the query part (even as\nthe right-hand side value of \"=\") ",
            {
              "vdoc:em": true,
              "vdoc:content": [
                "as long as the URI\nconsumer or possible middlewares don't perform x-www-form-urlencoded\n(or other) decoding of the key-value pairs"
              ]
            },
            "before VPath expansion."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "Rules out \"=\" , \"&\" from structural characters.\n",
            {
              "vdoc:blockquote": true,
              "vdoc:content": [
                "Note: This is completely regular. If the consumer is\n  known to explicitly decode query values and because VPaths can\n  contain \"%\" characters they must be appropriately symmetrically\n  encoded. This can result in double encoding. However as the intent is\n  that VPath expansion should be considered to be part of ",
                {
                  "@type": "vdoc:Reference",
                  "vdoc:content": [
                    "the URI parsing and separation itself"
                  ],
                  "vdoc:ref": "https://tools.ietf.org/html/rfc3986#section-2.4"
                },
                " any  separate encoding and decoding should not be needed."
              ]
            }
          ]
        }
      ]
    },
    "section_unencoded_in_rfc_3986_fragment": {
      "@id": "section_unencoded_in_rfc_3986_fragment",
      "dc:title": "As RFC 3986 URI fragment component",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nDoesn't rule out any delimiter options not yet ruled out."
          ]
        }
      ]
    },
    "section_unencoded_in_rfc_8141_nss": {
      "@id": "section_unencoded_in_rfc_8141_nss",
      "dc:title": "As RFC 8141 URN NSS components",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nDoesn't rule out any delimiter options not yet ruled out.\nSpecifically this does not rule out \":\" as that is allowed in NSS sub-parts."
          ]
        }
      ]
    },
    "section_unencoded_in_rfc_8141_rq_f": {
      "@id": "section_unencoded_in_rfc_8141_rq_f",
      "dc:title": "As RFC 8141 URN rq-, and f-component",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nCovered by URI query and fragment sections."
          ]
        }
      ]
    },
    "section_encoded_contexts": {
      "@id": "section_encoded_contexts",
      "dc:title": "VPath must be used escaped/quoted/encoded in following contexts",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@id": "section_quoted_string"
        },
        {
          "@id": "section_in_rfc_3986_segment_nz_nc"
        },
        {
          "@id": "section_x_www_form_urlencoded"
        }
      ]
    },
    "section_quoted_string": {
      "@id": "section_quoted_string",
      "dc:title": "In HTTP/1.1 headers always as a quoted-string",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nURI's in general need to be quoted here and VPath is URI-like.\nThis retains \"@\" as an allowed delimiter."
          ]
        }
      ]
    },
    "section_x_www_form_urlencoded": {
      "@id": "section_x_www_form_urlencoded",
      "dc:title": "In form fields as x-www-form-urlencoded",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nEncoded and serialized as per ",
            {
              "@type": "vdoc:Reference",
              "vdoc:content": [
                "https://url.spec.whatwg.org/#urlencoded-serializing"
              ],
              "vdoc:ref": "https://url.spec.whatwg.org/#urlencoded-serializing"
            }
          ]
        }
      ]
    },
    "section_in_rfc_3986_segment_nz_nc": {
      "@id": "section_in_rfc_3986_segment_nz_nc",
      "dc:title": "In URI relative-part with no scheme must be prefixed with \"./\"",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nThis retains \":\" as an allowed delimiter which segment-nz-nc would\notherwise prevent."
          ]
        }
      ]
    },
    "section_tilde_problem": {
      "@id": "section_tilde_problem",
      "dc:title": "The tilde problem with URN RFC 2141 is solved by RFC 8141",
      "@type": "vdoc:Chapter",
      "vdoc:content": [
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "\nRFC 2141 reserves \"~\" but encodeURIComponent doesn't encode it. To\nmaintain direct drop-in 2141 compatibility would require disallowing\n\"~\" from the character set. This in turn would complicate specific\njavascript domain implementations as they would have to encode \"~\"\nseparately without being able to solely rely on encodeURIComponent."
          ]
        },
        {
          "@type": "vdoc:Paragraph",
          "vdoc:content": [
            "As this concern is not likely to be a problem in practice anyway we\nchoose to refer to RFC 8141 for URN's which removes \"~\" from the set of\nreserved character. This solves this (relatively theoretical) issue."
          ]
        }
      ]
    },
    "@type": "revdoc:Document",
    "vdoc:content": [
      {
        "@id": "abstract"
      },
      {
        "@id": "sotd"
      },
      {
        "@id": "introduction"
      },
      {
        "@id": "section_structure"
      },
      {
        "@id": "section_semantics"
      },
      {
        "@id": "section_vrid"
      },
      {
        "@id": "section_grammar"
      },
      {
        "@id": "section_encoding_considerations"
      }
    ]
  }
]