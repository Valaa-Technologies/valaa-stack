// @flow

import React from "react";

import { addSourceEntryInfo, addStackFrameToError, SourceInfoTag } from "~/raem/VALK/StackTrace";

import VALEK, { Kuery, EngineKuery, VS, IsLiveTag, engineSteppers } from "~/engine/VALEK";

import UIComponent, { LENS } from "~/inspire/ui/UIComponent";
import Valens, { ValensPropsTag, tryCreateValensArgs } from "~/inspire/ui/UIComponent/Valens";
import vidgets from "~/inspire/ui";
import Valoscope from "~/inspire/ui/Valoscope";
import _jsxTransformFromString from "~/inspire/mediaDecoders/_jsxTransformFromString";

import { ScopeAccessesTag, ScopeAccessKeysTag } from "~/script/VALSK";

import MediaDecoder from "~/tools/MediaDecoder";
import notThatSafeEval from "~/tools/notThatSafeEval";
import { dumpObject } from "~/tools";

const { symbols: Lens, deprecatedNames } = require("~/inspire/Lens");

export default class JSXDecoder extends MediaDecoder {
  static mediaTypes = [
    { type: "text", subtype: "jsx" },
  ];

  static columnOffset = 0;

  constructor (options) {
    super(options);
    this._globalEngineDiscourse = options.gateway.discourse
        && Object.create(options.gateway.discourse);
    this._globalEngineDiscourse.setSteppers(engineSteppers);
    this._globalEngineDiscourse._rootDiscourse = this._globalEngineDiscourse;
  }

  decode (buffer: ArrayBuffer, { chronicleName, mediaName }: Object = {}): any {
    if (!buffer) return null;
    const sourceInfo: Object = {
      chronicleName,
      mediaName,
      phaseBase: `'${mediaName}'/'${chronicleName}' as ${this.type}/${this.subtype}`,
      phase: undefined,
      sourceMap: new Map(),
    };
    try {
      const originalSource = this.stringFromBuffer(buffer);
      sourceInfo.source = `<UIComponent>${originalSource}</UIComponent>`;
      sourceInfo.phase = `decode-jsx-transform phase of ${sourceInfo.phaseBase}`;
      try {
        sourceInfo.jsxTransformedSource = _jsxTransformFromString(sourceInfo.source,
          this._getJSXTransformOptions(sourceInfo));
      } catch (error) {
        if (!error.column || !error.lineNumber) throw error;
        sourceInfo.source = originalSource;
        const loc = {
          start: { line: error.lineNumber, column: error.column }, // 3?
          end: { line: error.lineNumber, column: error.column + 1 },
        };
        throw addStackFrameToError(error, addSourceEntryInfo(sourceInfo, {}, { loc }), sourceInfo);
      }
      return this._decodeIntoIntegrator(sourceInfo, sourceInfo.jsxTransformedSource);
    } catch (error) {
      throw this.wrapErrorEvent(error, 1, `decode(${sourceInfo.phaseBase})`,
          "\n\tsource:", sourceInfo.source);
    }
  }

  _getJSXTransformOptions (sourceInfo?: Object): Object {
    const ret = {
      factory: "createElement",
      spreadFn: "spread",
      unknownTagsAsString: true,
      passUnknownTagsToFactory: true,
      transformExpressionText: undefined,
    };
    if (sourceInfo) {
      ret.transformExpressionText = (text: any, start: { line?: number, column?: number } = {},
          end: { line?: number, column?: number } = {}) =>
              `addSourceInfo(${text}, ${start.line}, ${start.column}, ${end.line}, ${end.column})`;
    }
    return ret;
  }

  _decodeIntoIntegrator (topLevelSourceInfo: Object, transformedSource: string) {
    const sourceInfo = {
      ...topLevelSourceInfo,
    };
    try {
      const scope = this._createDecodeScope(sourceInfo);
      sourceInfo.phase = `decode-eval phase of ${sourceInfo.phaseBase}`;
      const rootElementBindKeys = notThatSafeEval(scope, `return ${transformedSource}`);
      // Note: keys that start with '-' are treated as autogenerated. All other keys are considered
      // as custom user provided keys. For example lens instances use custom keys to store
      // themselves inside parent instance owner properties.
      const rootChildrenMeta = this._createChildrenMeta();
      delete sourceInfo.currentLoc;
      const integrator = rootElementBindKeys(
          encodeURIComponent(sourceInfo.mediaName), rootChildrenMeta);
      sourceInfo.phase = `run phase of ${sourceInfo.phaseBase}`;
      return integrator;
    } catch (error) {
      const wrappedError = this.wrapErrorEvent(error, 1,
          `_decodeIntoIntegrator(${sourceInfo.phaseBase}):`,
          "\n\tsourceInfo:", sourceInfo);
      if (!sourceInfo || !error.column || !error.lineNumber) throw wrappedError;
      const loc = {
        start: { line: error.lineNumber, column: error.column - 1 }, // 3?
        end: { line: error.lineNumber, column: error.column },
      };
      throw addStackFrameToError(wrappedError,
          addSourceEntryInfo(sourceInfo, {}, { loc }),
          sourceInfo);
    }
  }

  _createDecodeScope (sourceInfo: Object) {
    return {
      LENS,
      VS,
      VALK: VALEK,
      kuery: (kuery: EngineKuery = VALEK.head()) =>
          ({ kuery: (kuery instanceof Kuery) ? kuery : VALEK.to(kuery) }),
      addSourceInfo: (embeddedContent, startLine, startColumn, endLine, endColumn) => {
        sourceInfo.currentLoc = {
          start: { line: startLine, column: startColumn },
          end: { line: endLine, column: endColumn },
        };
        return this._addKuerySourceInfo(
            embeddedContent, sourceInfo, sourceInfo.currentLoc);
      },
      spread: (...rest) => Object.assign(...rest),
      createElement: (type, props, ...restChildren) => {
        const self = this;
        const loc = sourceInfo.currentLoc || { start: {} }; // does not work yet
        _recurseWithKeys._isKeyRecurser = true;
        return _recurseWithKeys;
        function _recurseWithKeys (parentKey: string, parentChildrenMeta: Object) {
          try {
            return self._createKeyedElement(
                sourceInfo, loc, type, props, restChildren, parentKey, parentChildrenMeta);
          } catch (error) {
            const origin = new Error(`_createKeyedElement(${parentKey})`);
            const wrappedError = self.wrapErrorEvent(error, 0, () => [
              origin,
              "\n\ttype:", ...dumpObject(type),
              "\n\tprops:", ...dumpObject(props),
              "\n\trestChildren:", ...dumpObject(restChildren),
            ]);
            if (sourceInfo) {
              addStackFrameToError(wrappedError,
                  addSourceEntryInfo(sourceInfo, {}, { loc }), sourceInfo, origin, this);
            }
            throw wrappedError;
          }
        }
      },
    };
  }

  _addKuerySourceInfo (embeddedContent: any, outerSourceInfo: Object, loc: Object) {
    if (typeof embeddedContent !== "object" || embeddedContent === null) return embeddedContent;
    if (!(embeddedContent instanceof Kuery)) {
      const entries = Array.isArray(embeddedContent) ? embeddedContent
          : (Object.getPrototypeOf(embeddedContent) === Object.prototype)
              ? Object.values(embeddedContent)
              : [];
      entries.forEach(entry => this._addKuerySourceInfo(entry, outerSourceInfo, loc));
      return embeddedContent;
    }
    const sourceInfo: any = embeddedContent[SourceInfoTag];
    if (!sourceInfo) {
      addSourceEntryInfo(outerSourceInfo, embeddedContent.toVAKON(),
          { loc: { start: { ...loc.start }, end: { ...loc.end } } });
    } else {
      for (const [key, entry] of sourceInfo.sourceMap) {
        const start = { ...entry.loc.start };
        const end = { ...entry.loc.end };
        if (start.line === 1) start.column += loc.start.column + this.constructor.columnOffset;
        if (end.line === 1) end.column += loc.start.column + this.constructor.columnOffset;
        start.line += loc.start.line - 1;
        end.line += loc.start.line - 1;
        addSourceEntryInfo(outerSourceInfo, key, { ...entry, loc: { start, end } });
      }
    }
    embeddedContent[SourceInfoTag] = outerSourceInfo;
    return embeddedContent;
  }

  static _nameAbbreviations = {
    div: "d",
    span: "s",
    UIComponent: "UIC",
    ValaaScope: "VSC",
    Valoscope: "VSC",
    Valens: "VLE",
  };

  _createKeyedElement (sourceInfo, loc, type, props, restChildren, parentKey, parentChildrenMeta) {
    let actualType = type;
    let name;
    let isInstanceLens = false;
    if (typeof type !== "string") {
      name = type.name; // builtin react components
    } else {
      name = type; // lowercase names are builtin elements
      if (type[0] !== type[0].toLowerCase()) {
        // uppercase are vidgets and instance lenses, always ui components
        isInstanceLens = !vidgets[type];
        actualType = vidgets[type] || Valoscope;
      }
    }
    const children = [].concat(...restChildren);
    if ((actualType === UIComponent)
        && (children.length === 1)
        && (!props || (Object.keys(props).length === 0))) {
      const candidate = _maybeRecurseWithKey(children[0], parentKey, parentChildrenMeta);
      if (candidate == null || candidate._isElementIntegrator || React.isValidElement(candidate)) {
        return candidate;
      }
    }
    const elementPrefix = JSXDecoder._nameAbbreviations[name] || name;
    const elementIndex = (parentChildrenMeta.nameIndices[name] =
      (parentChildrenMeta.nameIndices[name] || 0) + 1) - 1;
    const elementKey = `${elementPrefix}(${elementIndex})`;
    const sourceKey = `${parentKey || ""}-${elementKey}`;

    let decodedType = actualType;
    let decodedProps;
    let propsMeta;
    if (props || isInstanceLens) {
      propsMeta = this._createPropsMeta(
          sourceInfo, loc, props || {}, name, isInstanceLens, actualType.isUIComponent, sourceKey);
      ([decodedType, decodedProps] = tryCreateValensArgs(
              actualType, propsMeta.decodedElementProps,
              sourceKey.slice((parentChildrenMeta.nearestFramedParentKey.length || -1) + 1))
          || [actualType, propsMeta.decodedElementProps]);
      if (decodedType === Valens) {
        decodedProps.sourceKey = sourceKey; // this is for debugging purposes mostly
      }
    }

    if (parentChildrenMeta.totalCount > 1) {
      if (!decodedProps) decodedProps = {};
      if (!decodedProps.key) decodedProps.key = elementKey;
    }

    const childrenMeta = this._createChildrenMeta(children, sourceKey,
        (actualType === Valoscope) || (propsMeta || "").hasFrame
            ? sourceKey
            : parentChildrenMeta.nearestFramedParentKey);

    if (!childrenMeta.hasIntegrators && !(propsMeta || "").hasIntegrators) {
      if (childrenMeta.hasKueries) {
        parentChildrenMeta.hasKueries = true;
        Object.assign(parentChildrenMeta.scopeAccesses
            || (parentChildrenMeta.scopeAccesses = {}), childrenMeta.scopeAccesses);
      }
      return _injectSourceInfoTag(
          React.createElement(decodedType, decodedProps, ...childrenMeta.decodedChildren),
          sourceInfo);
    }
    const self = this;
    function _elementIntegrator (integrationHostGlobal: Object) {
      try {
        let integratedProps = decodedProps;
        if (propsMeta && propsMeta.hasIntegrators) {
          integratedProps = {};
          for (const [propName, prop] of Object.entries(decodedProps)) {
            integratedProps[propName] = (typeof prop === "function") && prop._isIntegrator
                ? prop(integrationHostGlobal)
                : prop;
          }
          if (decodedType === Valens) {
            integratedProps.elementPropsSeq = decodedProps.elementPropsSeq
                .map(e => (((typeof e[1] === "function") && e[1]._isIntegrator)
                    ? [e[0], e[1](integrationHostGlobal)]
                    : e));
          }
        }
        const integratedChildren = !childrenMeta.hasIntegrators
            ? childrenMeta.decodedChildren
            : childrenMeta.decodedChildren.map(child =>
                _maybeIntegrate(child, integrationHostGlobal));
        return _injectSourceInfoTag(
            React.createElement(decodedType, integratedProps, ...integratedChildren),
            sourceInfo);
      } catch (error) {
        throw self.wrapErrorEvent(error, 1, () => [
          `createDecodeScope/${sourceInfo.mediaName} integration`,
          "\n\tintegrationHostGlobal:", ...dumpObject(integrationHostGlobal),
        ]);
      }
    }
    _elementIntegrator._isIntegrator = true;
    _elementIntegrator._isElementIntegrator = true;
    return _elementIntegrator;
  }

  _createChildrenMeta (children, parentKey, nearestFramedParentKey = "") {
    const ret = {
      hasIntegrators: false, hasKueries: false, totalCount: (children && children.length) || 0,
      scopeAccesses: {}, nameIndices: {}, nearestFramedParentKey,
    };
    ret.decodedChildren = (children || []).map(child =>
        _extractMetaOfValueInto(
            _maybeRecurseWithKey(child, parentKey, ret),
            ret,
            this._globalEngineDiscourse));
    return ret;
  }

  static _migrationDirectives = {
    class: ["className"],
    key: ["$Lens.frame"],
    elementKey: ["$Lens.frame", "warn"],
    focus: ["$Lens.focus"],
    head: ["$Lens.focus", "warn"],
    array: ["$Lens.array"],
    ref: ["$Lens.ref", "warn"],
    styleSheet: ["$Lens.styleSheet"],
    context: ["$Lens.context"],
    valoscope: ["$Lens.valoscope", "warn", "direct Lens:<property> notation"],
    vScope: ["$Lens.valoscope", "warn", "direct Lens:<property> notation"],
    valaaScope: ["$Lens.valoscope", "warn", "direct Lens:<property> notation"],
    ...Object.fromEntries(Object.entries(deprecatedNames)
        .map(([deprecated, favored]) => [deprecated, [`$Lens.${favored}`, "warn"]])),
  };

  _createPropsMeta (
      sourceInfo, loc, parsedProps, elementName, isInstanceLens, isComponentLens, sourceKey) {
    const ret = {
      hasIntegrators: false, hasKueries: false, totalCount: 0,
      scopeAccesses: {}, byNamespace: {}, decodedElementProps: {},
      hasFrame: elementName === "Valoscope" || isInstanceLens,
    };

    /* eslint-disable prefer-const */
    /*
    let {                                           // E  C  I
      key,                                          // ?     WL
      class: class_,                                // D  L  A
      focus, head, array, ref, styleSheet, context, // WL L  WL
      elementKey,                                   // WL WL WL
      vScope, valoscope, valaaScope,                // WL WL WL
      ...restAttrs
    } = parsedProps;
    */

    if (isInstanceLens) {
      ++ret.totalCount;
      parsedProps["$Lens.instanceLensPrototype"] = _getInstanceLensPrototypeKuery(elementName);
    }

    const staticKueriesByDefault = parsedProps["$Lens.static"]
        || (isComponentLens && !isInstanceLens && parsedProps.static);
    const defaultNamespace = !isComponentLens ? "HTML" : !isInstanceLens ? "Lens" : "Frame";
    const flattenedNamespace = !isComponentLens ? "HTML" : "Lens";

    for (let [attrName, attr] of Object.entries(parsedProps)) {
      try {
        _processAttribute.call(this, attrName, attr);
      } catch (error) {
        const origin = new Error(`_processAttribute(${attrName})`);
        const wrappedError = this.wrapErrorEvent(error, 0, () => [origin]);
        if (sourceInfo && attr instanceof Kuery) {
          const attrEntry = sourceInfo.sourceMap.get(attr.toVAKON());
          const entryInfo = { loc: {
            start: { ...attrEntry.loc.start },
            end: { ...attrEntry.loc.start },
          } };
          // wishful whitespaceless heuristics
          entryInfo.loc.start.column = Math.max(0,
              entryInfo.loc.start.column - 1 - (attrName.length || 1));
          entryInfo.loc.end.column -= 2;
          addStackFrameToError(wrappedError,
              addSourceEntryInfo(sourceInfo, {}, entryInfo),
              sourceInfo, origin, this);
        }
        throw wrappedError;
      }
    }
    function _processAttribute (attrName, attr) {
      let actualAttrName = attrName;
      const migration = JSXDecoder._migrationDirectives[attrName];
      if (migration && (migration[0].startsWith("$Lens") || isComponentLens)) {
        let [aliasOf, shouldWarn, warning] = migration;
        if ((shouldWarn === "warn")
            || ((shouldWarn === undefined) && (!isComponentLens || isInstanceLens))) {
          this.debugEvent(`DEPRECATED: non-namespaced attribute '${attrName}' in favor of ${
              warning || aliasOf.slice(1).replace(".", ":")} (in ${elementName} at ${sourceKey})`);
        }
        if (parsedProps[aliasOf] !== undefined) {
          throw new Error(`Attribute conflict found; the deprecated attribute '${
              attrName}' would alias to ${aliasOf.slice(1)} which has an existing value "${
              parsedProps[aliasOf]}" (in ${elementName} at ${sourceKey})`);
        }
        actualAttrName = aliasOf;
      }

      let [, namespace, name] = actualAttrName.match(/^\$([^.]+)\.(.*)$/)
          || [null, defaultNamespace, actualAttrName];
      let isLiveKuery = namespace.startsWith("live-") ? true
          : namespace.startsWith("static-") ? false
          : undefined;
      if (isLiveKuery !== undefined) namespace = namespace.slice(isLiveKuery ? 5 : 7);
      else if (staticKueriesByDefault) isLiveKuery = false;
      if (namespace === "Frame") ret.hasFrame = true;
      else if (namespace === "Lens") {
        if (name === "static") return;
        if (_valoscopeAttributes[name]) ret.hasFrame = true;
      }
      ++ret.totalCount;
      const namespaceAttrs = ret.byNamespace[namespace] || (ret.byNamespace[namespace] = {});
      if (namespaceAttrs[name] !== undefined) {
        this.debugEvent(`Overriding existing value of attribute ${namespace}:${name
            } by given attribute '${namespace}:${name
            }' (likely as a result of two aliased props, in ${elementName} at ${sourceKey})`);
      }
      const decodedValue = namespaceAttrs[name] =
          _extractMetaOfValueInto(attr, ret, this._globalEngineDiscourse, isLiveKuery);
      const propName = (namespace === flattenedNamespace) ? name : `$${namespace}.${name}`;
      ret.decodedElementProps[propName] = decodedValue;
    }
    return ret;
  }
}

const _valoscopeAttributes = {
  valoscope: true,
  frame: true,
  lens: true,
  lensProperty: true,
  focusLensProperty: true,
  delegateLensProperty: true,
  instanceLensProperty: true,
  instanceLensPrototype: true,
};

const _instanceLensPrototypeKueries = {};

function _getInstanceLensPrototypeKuery (elementName) {
  let ret = _instanceLensPrototypeKueries[elementName];
  if (!ret) {
    ret = _instanceLensPrototypeKueries[elementName] =
        VALEK.fromScope(Lens.integrationScopeResource)
            .propertyValue(elementName)
            .setScopeAccesses({ integrationScopeResource: "read" });
  }
  return ret;
}

const _scopeAccessLevels = {
  this: 1,
  window: 1,
  global: 1,
  valos: 1,
  Valaa: 1,
  console: 1,
  Array: 1,
  Object: 1,
};

function _extractMetaOfValueInto (value, meta, globalEngineDiscourse, isLiveIfKuery) {
  let ret = value;
  if (value instanceof Kuery) {
    const accesses = ret[ScopeAccessKeysTag];
    let accessLevel = accesses === undefined ? 0 : 2;
    for (const access of (accesses || [])) {
      if ((_scopeAccessLevels[access] || 0) < accessLevel) {
        accessLevel = _scopeAccessLevels[access] || 0;
      }
    }
    if (accessLevel === 2) {
      ret = globalEngineDiscourse.run(null, ret);
      if ((typeof ret === "object") && (ret != null)) {
        Object.freeze(ret);
      }
    } else {
      Object.assign(meta.scopeAccesses || (meta.scopeAccesses = {}), ret[ScopeAccessesTag]);
      if (accessLevel === 1) {
        ret = function _kueryIntegrator (integrationHostGlobal) {
          return integrationHostGlobal.valos.this.step(value);
        };
        ret._isIntegrator = true;
      } else {
        meta.hasKueries = true;
        if (isLiveIfKuery !== undefined) {
          ret = Object.create(Object.getPrototypeOf(ret), Object.getOwnPropertyDescriptors(ret));
          ret[IsLiveTag] = isLiveIfKuery;
        }
      }
    }
  }
  if (typeof ret === "function") {
    if (ret._isIntegrator) meta.hasIntegrators = true;
  }
  return ret;
}

function _maybeIntegrate (maybeIntegrator, integrationHostGlobal, mediaInfo) {
  return (typeof maybeIntegrator === "function") && maybeIntegrator._isIntegrator
      ? maybeIntegrator(integrationHostGlobal, mediaInfo)
      : maybeIntegrator;
}

function _maybeRecurseWithKey (maybeRecurser, parentKey, parentChildrenMeta) {
  return (typeof maybeRecurser === "function") && maybeRecurser._isKeyRecurser
      ? maybeRecurser(parentKey, parentChildrenMeta)
      : maybeRecurser;
}

function _injectSourceInfoTag (elementWOSourceInfo, sourceInfo) {
  const ret = Object.create( // unfreeze-hack so that we can write the tags
      Object.getPrototypeOf(elementWOSourceInfo),
      Object.getOwnPropertyDescriptors(elementWOSourceInfo));
  ret[SourceInfoTag] = sourceInfo;
  ret[ValensPropsTag] = null;
  return ret;
}
