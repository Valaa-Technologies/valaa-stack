// @flow

import React from "react";

import { addSourceEntryInfo, addStackFrameToError, SourceInfoTag } from "~/raem/VALK/StackTrace";

import VALEK, { Kuery, EngineKuery, VS } from "~/engine/VALEK";

import UIComponent, { LENS } from "~/inspire/ui/UIComponent";
import LivePropsPropsTag, { tryCreateLivePropsProps } from "~/inspire/ui/UIComponent/LiveProps";
import vidgets from "~/inspire/ui";
import Valoscope from "~/inspire/ui/Valoscope";
import _jsxTransformFromString from "~/inspire/mediaDecoders/_jsxTransformFromString";

import { ScopeAccessesTag } from "~/script/VALSK";

import MediaDecoder from "~/tools/MediaDecoder";
import notThatSafeEval from "~/tools/notThatSafeEval";
import { dumpObject } from "~/tools";

export default class JSXDecoder extends MediaDecoder {
  static mediaTypes = [
    { type: "text", subtype: "jsx" },
  ];

  static columnOffset = 0;

  decode (buffer: ArrayBuffer, { chronicleName, mediaName }: Object = {}): any {
    if (!buffer) return null;
    const sourceInfo: Object = {
      chronicleName,
      mediaName,
      phaseBase: `'${mediaName}'/'${chronicleName}' as ${this.type}/${this.subtype}`,
      phase: undefined,
      sourceMap: new Map(),
    };
    try {
      const originalSource = this.stringFromBuffer(buffer);
      sourceInfo.source = `<UIComponent>\n${originalSource}\n</UIComponent>`;
      sourceInfo.phase = `decode-jsx-transform phase of ${sourceInfo.phaseBase}`;
      try {
        sourceInfo.jsxTransformedSource = _jsxTransformFromString(sourceInfo.source,
          this._getJSXTransformOptions(sourceInfo));
      } catch (error) {
        if (!error.column || !error.lineNumber) throw error;
        sourceInfo.source = originalSource;
        const loc = {
          start: { line: error.lineNumber - 1, column: error.column - 1 }, // 3?
          end: { line: error.lineNumber - 1, column: error.column },
        };
        throw addStackFrameToError(error, addSourceEntryInfo(sourceInfo, {}, { loc }), sourceInfo);
      }
      return this._decodeIntoIntegrator(sourceInfo, sourceInfo.jsxTransformedSource);
    } catch (error) {
      throw this.wrapErrorEvent(error, 1, `decode(${sourceInfo.phaseBase})`,
          "\n\tsource:", sourceInfo.source);
    }
  }

  _getJSXTransformOptions (sourceInfo?: Object): Object {
    const ret = {
      factory: "createElement",
      spreadFn: "spread",
      unknownTagsAsString: true,
      passUnknownTagsToFactory: true,
      transformExpressionText: undefined,
    };
    if (sourceInfo) {
      ret.transformExpressionText = (text: any, start: { line?: number, column?: number } = {},
          end: { line?: number, column?: number } = {}) =>
              `addSourceInfo(${text}, ${start.line}, ${start.column}, ${end.line}, ${end.column})`;
    }
    return ret;
  }

  _decodeIntoIntegrator (topLevelSourceInfo: Object, transformedSource: string) {
    const sourceInfo = {
      ...topLevelSourceInfo,
    };
    try {
      const scope = this._createDecodeScope(sourceInfo);
      sourceInfo.phase = `decode-eval phase of ${sourceInfo.phaseBase}`;
      const rootElementBindKeys = notThatSafeEval(scope, `return ${transformedSource}`);
      // Note: keys that start with '-' are treated as autogenerated. All other keys are considered
      // as custom user provided keys. For example lens instances use custom keys to store
      // themselves inside parent instance owner properties.
      const rootChildrenMeta = this._createChildrenMeta();
      const integrator = rootElementBindKeys(`-${sourceInfo.mediaName}`, rootChildrenMeta);
      sourceInfo.phase = `run phase of ${sourceInfo.phaseBase}`;
      return integrator;
    } catch (error) {
      const wrappedError = this.wrapErrorEvent(error, 1,
          `_decodeIntoIntegrator(${sourceInfo.phaseBase}):`,
          "\n\tsourceInfo:", sourceInfo);
      if (!sourceInfo || !error.column || !error.lineNumber) throw wrappedError;
      const loc = {
        start: { line: error.lineNumber, column: error.column - 1 }, // 3?
        end: { line: error.lineNumber, column: error.column },
      };
      throw addStackFrameToError(wrappedError,
          addSourceEntryInfo(sourceInfo, {}, { loc }),
          sourceInfo);
    }
  }

  _createDecodeScope (sourceInfo: Object) {
    return {
      LENS,
      VS,
      VALK: VALEK,
      kuery: (kuery: EngineKuery = VALEK.head()) =>
          ({ kuery: (kuery instanceof Kuery) ? kuery : VALEK.to(kuery) }),
      addSourceInfo: (embeddedContent, startLine, startColumn, endLine, endColumn) =>
        this._addKuerySourceInfo(embeddedContent, sourceInfo,
            { line: startLine, column: startColumn }, { line: endLine, column: endColumn }),
      spread: (...rest) => Object.assign(...rest),
      createElement: (type, props, ...restChildren) =>
          (parentKey: string, parentChildrenMeta: Object) =>
              this._createKeyedElement(
                  sourceInfo, type, props, restChildren, parentKey, parentChildrenMeta),
    };
  }

  _addKuerySourceInfo (embeddedContent: any, outerSourceInfo: Object, start: Object, end: Object) {
    if (typeof embeddedContent !== "object" || embeddedContent === null) return embeddedContent;
    if (!(embeddedContent instanceof Kuery)) {
      const entries = Array.isArray(embeddedContent) ? embeddedContent
          : (Object.getPrototypeOf(embeddedContent) === Object.prototype)
              ? Object.values(embeddedContent)
              : [];
      entries.forEach(entry => this._addKuerySourceInfo(entry, outerSourceInfo, start, end));
      return embeddedContent;
    }
    const sourceInfo: any = embeddedContent[SourceInfoTag];
    if (!sourceInfo) {
      addSourceEntryInfo(outerSourceInfo, embeddedContent.toVAKON(), { loc: { start, end, } });
    } else {
      for (const [key, entry] of sourceInfo.sourceMap) {
        const loc = { start: { ...entry.loc.start }, end: { ...entry.loc.end } };
        if (loc.start.line === 1) {
          loc.start.column += start.column + this.constructor.columnOffset;
        }
        if (loc.end.line === 1) loc.end.column += start.column + this.constructor.columnOffset;
        loc.start.line += start.line - 1;
        loc.end.line += start.line - 1;
        addSourceEntryInfo(outerSourceInfo, key, { ...entry, loc });
      }
    }
    embeddedContent[SourceInfoTag] = outerSourceInfo;
    return embeddedContent;
  }

  _createChildrenMeta () {
    return {
      hasFunctions: false, hasKueries: false, nameIndices: {}, scopeAccesses: {}, count: 0,
    };
  }

  _createKeyedElement (sourceInfo, type, props, restChildren, parentKey, parentChildrenMeta) {
    let actualType = type;
    let name;
    let isInstanceLensType = false;
    if (typeof type !== "string") name = type.name; // builtin react components
    else { // lowercase = builtin elements, uppercase = vidgets and instance lenses
      name = type;
      if (type[0] !== type[0].toLowerCase()) {
        isInstanceLensType = !vidgets[type];
        actualType = vidgets[type] || Valoscope;
      }
    }

    let isComponentType = actualType.isUIComponent;
    const children = [].concat(...restChildren);
    if (isComponentType && (actualType === UIComponent)) {
      if ((!props || (Object.keys(props).length === 0)) && (children.length === 1)) {
        const child = children[0];
        return _extractMetaOfValueInto((typeof child !== "function")
                ? child
                : child(parentKey, parentChildrenMeta),
            parentChildrenMeta);
      }
    }

    const propsByNamespace = this._createPropsByNamespace(
        props, parentKey, parentChildrenMeta, name, isInstanceLensType, isComponentType);

    const propsMeta = { hasFunctions: false, hasKueries: false, count: 0 };
    const childrenMeta = this._createChildrenMeta();

    function _extractMetaOfValueInto (value, meta) {
      if (typeof value === "function") {
        meta.hasFunctions = true;
      } else if (value instanceof Kuery) {
        meta.hasKueries = true;
        const scopeAccesses = value[ScopeAccessesTag];
        if (scopeAccesses) {
          Object.assign(meta.scopeAccesses || (meta.scopeAccesses = {}), scopeAccesses);
        }
      }
      ++meta.count;
      return value;
    }

    const decodedProps = {};
    for (const [namespace, propsTarget] of Object.entries(propsByNamespace)) {
      if (!namespace) continue;
      for (const [propName, propValue] of Object.entries(propsTarget)) {
        if (propValue === undefined) continue;
        const encodedName = namespace === "L" ? propName : `$${namespace}.${propName}`;
        decodedProps[encodedName] = _extractMetaOfValueInto(propValue, propsMeta);
      }
    }
    if (propsMeta.hasFunctions) {
      throw new Error("internal error: propsMeta.hasFunctions should always be falsy");
    }

    const decodedChildren = children.map((child: any) => {
      const childWithKey = (typeof child !== "function")
          ? child
          : child(isComponentType ? "" : propsByNamespace.L.key, childrenMeta);
      return _extractMetaOfValueInto(childWithKey, childrenMeta);
    });
    if (propsMeta.hasKueries) {
      isComponentType = true;
    }
    if (!isComponentType && !childrenMeta.hasFunctions) {
      if (childrenMeta.hasKueries) {
        parentChildrenMeta.hasKueries = true;
        Object.assign(parentChildrenMeta.scopeAccesses
            || (parentChildrenMeta.scopeAccesses = {}), childrenMeta.scopeAccesses);
      }
      return this._injectSourceInfoAndLivePropsTags(
          !decodedChildren.length
              ? React.createElement(actualType, decodedProps)
              : React.createElement(actualType, decodedProps, decodedChildren),
          sourceInfo);
    }

    return (integrationHostGlobal: Object, mediaInfo: Object) => {
      try {
        const integrationFabricScope = integrationHostGlobal.valos;
        let integratedProps = decodedProps;
        if (isInstanceLensType) {
          integratedProps = {
            ...decodedProps,
            instanceLensPrototype: VALEK.fromValue(integrationFabricScope).propertyValue(type),
          };
          const vIntegrator = integrationFabricScope.this;
          if (!integrationFabricScope[type]) {
            throw new Error(`Cannot find lens instance prototype by name '${type
                }' from integration scope of ${vIntegrator.debugId()}`);
          }
        } else if (propsMeta.hasFunctions) {
          integratedProps = { ...decodedProps };
        }
        const element = !decodedChildren.length
                ? React.createElement(actualType, integratedProps)
            : !childrenMeta.hasFunctions
                ? React.createElement(actualType, integratedProps, decodedChildren)
                : React.createElement(actualType, integratedProps, decodedChildren
                    .map(child => (typeof child !== "function"
                        ? child
                        : child(integrationHostGlobal, mediaInfo))));
        return this._injectSourceInfoAndLivePropsTags(
            element,
            sourceInfo,
            tryCreateLivePropsProps(actualType, integratedProps /* , onRef */));
      } catch (error) {
        throw this.wrapErrorEvent(error, 1, () => [
          `createDecodeScope/${sourceInfo.mediaName} integration`,
          "\n\tintegrationHostGlobal:", ...dumpObject(integrationHostGlobal),
        ]);
      }
    };
  }

  _createPropsByNamespace (props, parentKey, parentChildrenMeta, name, isInstanceLensType,
      isComponentType) {
    /* eslint-disable prefer-const */
    let {
      focus, head, array,
      key, elementKey: globalId, class: className, ref: onRef,
      vScope, valoscope, valaaScope,
      ...restProps
    } = props || {};

    if (head !== undefined) {
      if (focus !== undefined) {
        throw new Error("Cannot provide both head and focus; use only focus (head is deprecated)");
      }
      this.warnEvent(`head is DEPRECATED in favor of focus`);
      focus = head;
    }
    if (isInstanceLensType) {
      if (key) this.warnEvent(`key is DEPRECATED in favor of $L.key (got ${key})`);
      if (globalId) {
        this.warnEvent(`elementKey is DEPRECATED in favor of $L.globalId (got ${globalId})`);
      }
      if (onRef) this.warnEvent(`ref is DEPRECATED in favor of $L.onRef (got ${onRef})`);
    }
    if (vScope || valoscope || valaaScope) {
      this.warnEvent(`Element props 'vScope', 'valoscope' and 'valaaScope' are DEPRECATED${
          ""} in favor of direct $L.<propname> notation`);
      valoscope = valoscope || vScope || valaaScope;
    }
    if (key) {
      if (key instanceof Kuery) {
        globalId = key;
        key = undefined; // key is used by react in LiveProps before a kuery can be resolved.
      } else if (isComponentType) {
        globalId = key;
      }
    }
    if (key === undefined) {
      const index = (parentChildrenMeta.nameIndices[name] =
            (parentChildrenMeta.nameIndices[name] || 0) + 1) - 1;
      key = `${name === "div" ? "d" : name === "span" ? "s" : name
        }#${index}<${typeof parentKey === "string" ? parentKey : "!"}`;
    }

    const lensProps = { focus, array, globalId, key, className, valoscope, onRef };
    const paramProps = {};
    const contextProps = {};
    const ret = {
      "": isInstanceLensType ? paramProps : lensProps,
      L: lensProps,
      C: contextProps,
      P: paramProps,
    };
    for (const [propName, propValue] of Object.entries(restProps)) {
      if (!isInstanceLensType && (propName[0] === "$")) {
        throw new Error(`Props name can't begin with '$', got: '${propName}'`);
      }
      const [, namespace, property] = propName.match(/^\$([^.]+)\.(.*)$/)
          || [null, "", propName];
      const namespaceProps = ret[namespace] || (ret[namespace] = {});
      if (namespaceProps[property] !== undefined) {
        this.warnEvent(
            `Overriding existing ${namespace ? `namespace '${namespace}' ` : "non-namespaced"
            } prop '${property}' (likely as a result of two aliased props)`);
      }
      namespaceProps[property] = propValue;
    }
    return ret;
  }

  _injectSourceInfoAndLivePropsTags (elementWOSourceInfo, sourceInfo, livePropsProps = null) {
    const ret = Object.create( // unfreeze-hack so that we can write the tags
        Object.getPrototypeOf(elementWOSourceInfo),
        Object.getOwnPropertyDescriptors(elementWOSourceInfo));
    ret[SourceInfoTag] = sourceInfo;
    ret[LivePropsPropsTag] = livePropsProps;
    return ret;
  }
}
